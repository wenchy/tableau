package protogen

import (
	"os"
	"path/filepath"
	"strings"

	"github.com/Wenchy/tableau/internal/atom"
	"github.com/Wenchy/tableau/internal/printer"
	"github.com/Wenchy/tableau/proto/tableaupb"
	"github.com/emirpasic/gods/sets/treeset"
	"github.com/golang/protobuf/proto"
	"github.com/pkg/errors"
	"google.golang.org/protobuf/encoding/prototext"
	"google.golang.org/protobuf/reflect/protoreflect"
)

type bookExporter struct {
	ProtoPackage string
	GoPackage    string
	OutputDir    string
	wb           *tableaupb.Workbook
}

func newBookExporter(protoPackage, goPackage, outputDir string, wb *tableaupb.Workbook) *bookExporter {
	return &bookExporter{
		ProtoPackage: protoPackage,
		GoPackage:    goPackage,
		OutputDir:    outputDir,
		wb:           wb,
	}
}

func (x *bookExporter) export() error {
	// atom.Log.Debug(proto.MarshalTextString(wb))
	g := NewGeneratedFile(x.wb.Name)

	g.P("// Generated by tableau-gen-proto ", version, ". DO NOT EDIT.")
	g.P(`syntax = "proto3";`)
	g.P("package ", x.ProtoPackage, ";")
	g.P(`option go_package = "`, x.GoPackage, `";`)
	g.P("")

	// keep the elements ordered by import path
	set := treeset.NewWithStringComparator()
	for key := range x.wb.Imports {
		set.Add(key)
	}
	for _, key := range set.Values() {
		g.P(`import "`, key, `";`)
	}
	g.P("")
	g.P("option (tableau.workbook) = {", genPrototext(x.wb.Options), "};")
	g.P("")

	for i, ws := range x.wb.Worksheets {
		exporter := &sheetExporter{
			ws:             ws,
			g:              g,
			isLastSheet:    i == len(x.wb.Worksheets)-1,
			nestedMessages: make(map[string]*tableaupb.Field),
		}
		if err := exporter.export(); err != nil {
			return err
		}
	}

	path := filepath.Join(x.OutputDir, x.wb.Name)
	atom.Log.Debugf("output: %s", path)

	if f, err := os.Create(path); err != nil {
		return errors.Wrapf(err, "failed to create output file: %s", path)
	} else {
		defer f.Close()
		if _, err = f.Write(g.Content()); err != nil {
			return errors.Wrapf(err, "failed to write output file: %s", path)
		}
	}

	return nil
}

type sheetExporter struct {
	ws             *tableaupb.Worksheet
	g              *GeneratedFile
	isLastSheet    bool
	nestedMessages map[string]*tableaupb.Field // type name -> field
}

func (x *sheetExporter) export() error {
	x.g.P("message ", x.ws.Name, " {")
	x.g.P("  option (tableau.worksheet) = {", genPrototext(x.ws.Options), "};")
	x.g.P("")
	// generate the fields
	depth := 1
	for i, field := range x.ws.Fields {
		tagid := i + 1
		if err := x.exportField(depth, tagid, field); err != nil {
			return err
		}
	}
	x.g.P("}")
	if !x.isLastSheet {
		x.g.P("")
	}
	return nil
}

func (x *sheetExporter) exportField(depth int, tagid int, field *tableaupb.Field) error {
	// head := "%x%x"
	cardTypeSep := ""
	if field.Card != "" {
		// head += " " // cardinality exists
		cardTypeSep = " "
	}
	// x.g.P(head+"%x %x = %d [(tableau.field) = {%x}];", printer.Indent(depth), field.Card, field.Type, field.Name, tagid, genPrototext(field.Options))
	x.g.P(printer.Indent(depth), field.Card, cardTypeSep, field.Type, " ", field.Name, " = ", tagid, " [(tableau.field) = {", genPrototext(field.Options), "}];")

	if !field.TypeDefined && field.Fields != nil {
		// iff field is a map or list and message type is not imported.
		nestedMsgName := field.Type
		if field.MapEntry != nil {
			nestedMsgName = field.MapEntry.ValueType
		}

		if isSameFieldMessageType(field, x.nestedMessages[nestedMsgName]) {
			// if the nested message is the same as the previous one,
			// just use the previous one, and don't generate a new one.
			return nil
		}

		// bookkeeping this nested msessage, so we can check if we can reuse it later.
		x.nestedMessages[nestedMsgName] = field

		x.g.P("")
		x.g.P(printer.Indent(depth), "message ", nestedMsgName, " {")
		for i, f := range field.Fields {
			tagid := i + 1
			if err := x.exportField(depth+1, tagid, f); err != nil {
				return err
			}
		}
		x.g.P(printer.Indent(depth), "}")
	}
	return nil
}

func genPrototext(m protoreflect.ProtoMessage) string {
	// text := proto.CompactTextString(field.Options)
	bin, err := prototext.Marshal(m)
	if err != nil {
		panic(err)
	}
	// NOTE: remove redundant spaces/whitespace from a string
	// refer: https://stackoverflow.com/questions/37290693/how-to-remove-redundant-spaces-whitespace-from-a-string-in-golang
	text := strings.Join(strings.Fields(string(bin)), " ")
	return text
}



func isSameFieldMessageType(left, right *tableaupb.Field) bool {
	if left == nil || right == nil {
		return false
	}
	if left.Fields == nil || right.Fields == nil {
		return false
	}
	if len(left.Fields) != len(right.Fields) ||
		left.Type != right.Type ||
		left.Card != right.Card {
		return false
	}

	for i, l := range left.Fields {
		r := right.Fields[i]
		if !proto.Equal(l, r) {
			return false
		}
	}
	return true
}
